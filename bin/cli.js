#!/usr/bin/env node

import fs from "fs";
import http from "http";
import path from "path";
import { exec } from "child_process";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DEFAULT_FOLDER = "spec";
const VIEW_PORT = 4173;
const args = process.argv.slice(2);
const command = args[0];

const AGENTS_START = "<!-- spec-feature:agents:start -->";
const AGENTS_END = "<!-- spec-feature:agents:end -->";

if (command === "init") {
  const targetDir = process.cwd();
  const folderName = args[1] || DEFAULT_FOLDER;
  const destinationDir = path.join(targetDir, folderName);
  const templateDir = path.join(__dirname, "..", DEFAULT_FOLDER);

  if (!fs.existsSync(templateDir)) {
    console.error(`‚ùå Template directory not found: ${templateDir}`);
    process.exit(1);
  }

  function copyRecursive(src, dest, relative = "") {
    const stat = fs.statSync(src);

    if (stat.isDirectory()) {
      if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
        if (relative) {
          console.log(`Created: ${folderName}/${relative}`);
        }
      }

      fs.readdirSync(src).forEach(entry => {
        const nextRelative = relative ? `${relative}/${entry}` : entry;
        copyRecursive(path.join(src, entry), path.join(dest, entry), nextRelative);
      });
      return;
    }

    if (fs.existsSync(dest)) {
      console.log(`Skipped (already exists): ${folderName}/${relative}`);
      return;
    }

    fs.copyFileSync(src, dest);
    console.log(`Created: ${folderName}/${relative}`);
  }

  if (!fs.existsSync(destinationDir)) {
    fs.mkdirSync(destinationDir, { recursive: true });
  }

  copyRecursive(templateDir, destinationDir);

  const agentsWorkflowBlock = `${AGENTS_START}

## spec-feature workflow

This repository uses **spec-feature** to define features as structured documents before implementation.

### Templates origin

The \`spec/\` directory is generated by running \`npx spec-feature init\` in the repository root (typically by a human during project setup). Treat files under \`spec/core/\` as canonical templates for creating and updating feature artifacts.

### Structure

- \`spec/core/\` ‚Äî templates: \`spec.md\`, \`plan.md\`, \`tasks.md\`, \`verify.md\`, \`hotfix.md\`
- \`spec/feature.md\` ‚Äî unified prompt template to create/update a feature
- \`spec/features/<feature>/{spec.md,plan.md,tasks.md}\` ‚Äî generated feature artifacts
- \`spec/features/<feature>/verify-report.md\` ‚Äî verification output (after tasks / manual verify)

### Create or update a feature

Use the template from \`spec/feature.md\` and provide input as:

\`#<feature># <context>\`

Result: create/update the folder \`spec/features/<feature>/\` and produce \`spec.md\` ‚Üí \`plan.md\` ‚Üí \`tasks.md\`.

### Execute tasks

When implementation is requested, execute tasks from:\n\n- \`spec/features/<feature>/tasks.md\`

### Verify

Use \`spec/core/verify.md\` to verify \`spec/features/<feature>/\` and write \`verify-report.md\`.

### Quality bar (for generated artifacts)

- No empty headers, no placeholders
- \`spec.md\`: at least 3 user stories + explicit assumptions
- \`plan.md\`: references concrete decisions from \`spec.md\` (avoid generic plans)
- \`tasks.md\`: checkable, ordered, references concrete paths under \`spec/features/<feature>/\`
- If updating an existing feature, prefer updating existing files; use \`spec/core/hotfix.md\` to describe changes

${AGENTS_END}
`;

  const agentsPath = path.join(targetDir, "AGENTS.md");
  const agentsBlockRegex = new RegExp(
    `${escapeRegExp(AGENTS_START)}[\\s\\S]*?${escapeRegExp(AGENTS_END)}`,
    "m",
  );

  try {
    if (!fs.existsSync(agentsPath)) {
      const initialAgents = `# AGENTS\n\n${agentsWorkflowBlock}\n`;
      fs.writeFileSync(agentsPath, initialAgents, "utf8");
      console.log("Created: AGENTS.md");
    } else {
      const existingAgents = fs.readFileSync(agentsPath, "utf8");
      if (existingAgents.includes(AGENTS_START) && existingAgents.includes(AGENTS_END)) {
        const updatedAgents = existingAgents.replace(agentsBlockRegex, agentsWorkflowBlock).replace(/\s*$/, "\n");
        if (updatedAgents !== existingAgents) {
          fs.writeFileSync(agentsPath, updatedAgents, "utf8");
          console.log("Updated: AGENTS.md (spec-feature block)");
        } else {
          console.log("Skipped: AGENTS.md (spec-feature block unchanged)");
        }
      } else {
        const trimmed = existingAgents.replace(/\s*$/, "");
        const appendedAgents = `${trimmed}\n\n${agentsWorkflowBlock}\n`;
        fs.writeFileSync(agentsPath, appendedAgents, "utf8");
        console.log("Appended: AGENTS.md (spec-feature workflow)");
      }
    }
  } catch (err) {
    console.error("‚ùå Failed to write AGENTS.md:", err?.message || err);
    process.exit(1);
  }

  console.log(`‚úÖ Spec Feature initialized in '${folderName}' folder!`);
  process.exit(0);
  process.exit(0);
} else if (command === "view") {
  const { targetFeature, folderName } = parseViewArgs(args.slice(1));
  const htmlPath = path.join(__dirname, "viewer.html");
  const baseFolder = path.join(process.cwd(), folderName);
  const featuresRoot = path.join(baseFolder, "features");

  if (!fs.existsSync(htmlPath)) {
    console.error(`‚ùå Viewer file not found: ${htmlPath}`);
    process.exit(1);
  }

  if (!fs.existsSync(baseFolder)) {
    console.error(
      `‚ùå Folder not found: ${baseFolder}. Use --folder/-f to point to the specs root (it must contain "core/", "feature.md"). Example: npx spec-feature view --folder spec`,
    );
    process.exit(1);
  }

  const isInitialized = isSpecFeatureInitialized(baseFolder);

  if (!isInitialized) {
    console.error(
      `‚ùå Spec Feature is not initialized in ${baseFolder}. Run "npx spec-feature init" (or point to the correct folder with --folder/-f).`,
    );
    process.exit(1);
  }

  if (!fs.existsSync(featuresRoot)) {
    fs.mkdirSync(featuresRoot, { recursive: true });
  }

  const hasFeatures = hasAnyFeatures(featuresRoot);

  const server = http.createServer((req, res) => {
    const url = new URL(req.url, `http://localhost:${VIEW_PORT}`);

    if (url.pathname === "/api/features") {
      try {
        const payload = readFeatures(featuresRoot);
        res.writeHead(200, { "Content-Type": "application/json; charset=utf-8" });
        res.end(JSON.stringify(payload));
      } catch (err) {
        console.error("‚ùå Failed to read features:", err?.message || err);
        res.writeHead(500, { "Content-Type": "application/json; charset=utf-8" });
        res.end(JSON.stringify({ error: "Failed to read features" }));
      }
      return;
    }

    fs.readFile(htmlPath, "utf8", (err, data) => {
      if (err) {
        console.error("‚ùå Failed to read viewer.html:", err?.message || err);
        res.writeHead(500, { "Content-Type": "text/plain" });
        res.end("Internal server error");
        return;
      }

      const configScript = `<script>window.SPEC_FEATURE_CONFIG = ${JSON.stringify({
        folderName,
        targetFeature,
        hasFeatures,
        isInitialized,
      })};</script>`;

      const htmlWithConfig = data.replace(
        "<!-- spec-feature:config:inject -->",
        configScript,
      );

      res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
      res.end(htmlWithConfig);
    });
  });

  server.on("error", err => {
    if (err?.code === "EADDRINUSE") {
      console.error(`‚ùå Port ${VIEW_PORT} is already in use. Please free it and try again.`);
    } else {
      console.error("‚ùå Failed to start viewer server:", err?.message || err);
    }
    process.exit(1);
  });

  const sockets = new Set();

  // Track active sockets so we can destroy them on shutdown
  server.on("connection", socket => {
    sockets.add(socket);
    socket.on("close", () => sockets.delete(socket));
  });

  server.listen(VIEW_PORT, () => {
    const featureQuery = targetFeature ? `?feature=${encodeURIComponent(targetFeature)}` : "";
    const url = `http://localhost:${VIEW_PORT}/${featureQuery}`;
    console.log(`üìÑ Viewer running at ${url}`);
    openBrowser(url);
  });

  const shutdown = signal => {
    console.log(`\nReceived ${signal}, shutting down viewer...`);
    server.close(() => process.exit(0));
    sockets.forEach(socket => socket.destroy());
    // Fallback in case sockets hang
    setTimeout(() => process.exit(0), 1000).unref();
  };

  // Keep process alive until manual stop (Ctrl+C)
  process.once("SIGINT", () => shutdown("SIGINT"));
  process.once("SIGTERM", () => shutdown("SIGTERM"));
} else {
  console.log("Usage: npx spec-feature init [folder-name]");
  console.log("       npx spec-feature view [feature-name] [--folder|-f folder]");
  process.exit(1);
}

function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function openBrowser(url) {
  const platform = process.platform;
  const command =
    platform === "win32"
      ? `start "" "${url}"`
      : platform === "darwin"
        ? `open "${url}"`
        : `xdg-open "${url}"`;

  exec(command, err => {
    if (err) {
      console.error("‚ö†Ô∏è Failed to open browser automatically. Please open the URL manually:", url);
    }
  });
}

function parseViewArgs(restArgs) {
  let targetFeature = "";
  let folderName = DEFAULT_FOLDER;

  for (let i = 0; i < restArgs.length; i++) {
    const val = restArgs[i];

    if (val === "--folder" || val === "-f") {
      const next = restArgs[i + 1];
      if (!next || next.startsWith("-")) {
        console.error("‚ùå Missing folder name after --folder/-f");
        process.exit(1);
      }
      folderName = next;
      i++;
      continue;
    }

    if (!targetFeature) {
      targetFeature = val;
    }
  }

  return { targetFeature, folderName };
}

function readFeatures(featuresRoot) {
  if (!fs.existsSync(featuresRoot)) return [];

  const entries = fs.readdirSync(featuresRoot, { withFileTypes: true });

  const features = entries
    .filter(d => d.isDirectory())
    .map(dirent => {
      const featureId = dirent.name;
      const featurePath = path.join(featuresRoot, featureId);
      const files = ["spec.md", "plan.md", "tasks.md", "verify-report.md"]
        .filter(name => fs.existsSync(path.join(featurePath, name)))
        .map(name => {
          const content = fs.readFileSync(path.join(featurePath, name), "utf8");
          const type = name.startsWith("spec")
            ? "spec"
            : name.startsWith("plan")
              ? "plan"
              : name.startsWith("tasks")
                ? "tasks"
                : "verify";
          return {
            id: type,
            name,
            type,
            description: describeFile(type),
            content,
          };
        });

      const progress = calculateTasksProgress(files);

      return {
        id: featureId,
        title: humanize(featureId),
        status: progress.percentage === 100 ? "done" : progress.total > 0 ? "in-progress" : "pending",
        progress,
        files,
      };
    });

  return features;
}

function humanize(slug) {
  return slug
    .split(/[-_]/g)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function describeFile(type) {
  if (type === "spec") return "Specification";
  if (type === "plan") return "Plan";
  if (type === "tasks") return "Tasks";
  if (type === "verify") return "Verify report";
  return "Document";
}

function calculateTasksProgress(files) {
  const tasksFile = files.find(f => f.type === "tasks");
  if (!tasksFile) return { completed: 0, total: 0, percentage: 0 };

  const completed = (tasksFile.content.match(/- \[x\]/g) || []).length;
  const pending = (tasksFile.content.match(/- \[ \]/g) || []).length;
  const total = completed + pending;
  return {
    completed,
    total,
    percentage: total === 0 ? 0 : Math.round((completed / total) * 100),
  };
}

function isSpecFeatureInitialized(baseFolder) {
  const hasCore = fs.existsSync(path.join(baseFolder, "core"));
  const hasFeatureTemplate = fs.existsSync(path.join(baseFolder, "feature.md"));
  return hasCore && hasFeatureTemplate;
}

function hasAnyFeatures(featuresRoot) {
  if (!fs.existsSync(featuresRoot)) return false;
  return fs.readdirSync(featuresRoot, { withFileTypes: true }).some(entry => entry.isDirectory());
}
