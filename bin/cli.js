#!/usr/bin/env node

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DEFAULT_FOLDER = "spec";
const args = process.argv.slice(2);
const command = args[0];

const AGENTS_START = "<!-- spec-feature:agents:start -->";
const AGENTS_END = "<!-- spec-feature:agents:end -->";

if (command === "init") {
  const targetDir = process.cwd();
  const folderName = args[1] || DEFAULT_FOLDER;
  const destinationDir = path.join(targetDir, folderName);
  const templateDir = path.join(__dirname, "..", DEFAULT_FOLDER);

  if (!fs.existsSync(templateDir)) {
    console.error(`❌ Template directory not found: ${templateDir}`);
    process.exit(1);
  }

  function copyRecursive(src, dest, relative = "") {
    const stat = fs.statSync(src);

    if (stat.isDirectory()) {
      if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
        if (relative) {
          console.log(`Created: ${folderName}/${relative}`);
        }
      }

      fs.readdirSync(src).forEach(entry => {
        const nextRelative = relative ? `${relative}/${entry}` : entry;
        copyRecursive(path.join(src, entry), path.join(dest, entry), nextRelative);
      });
      return;
    }

    if (fs.existsSync(dest)) {
      console.log(`Skipped (already exists): ${folderName}/${relative}`);
      return;
    }

    fs.copyFileSync(src, dest);
    console.log(`Created: ${folderName}/${relative}`);
  }

  if (!fs.existsSync(destinationDir)) {
    fs.mkdirSync(destinationDir, { recursive: true });
  }

  copyRecursive(templateDir, destinationDir);

  const agentsWorkflowBlock = `${AGENTS_START}

## spec-feature workflow

This repository uses **spec-feature** to define features as structured documents before implementation.

### Templates origin

The \`spec/\` directory is generated by running \`npx spec-feature init\` in the repository root (typically by a human during project setup). Treat files under \`spec/core/\` as canonical templates for creating and updating feature artifacts.

### Structure

- \`spec/core/\` — templates: \`spec.md\`, \`plan.md\`, \`tasks.md\`, \`verify.md\`, \`hotfix.md\`
- \`spec/feature.md\` — unified prompt template to create/update a feature
- \`spec/features/<feature>/{spec.md,plan.md,tasks.md}\` — generated feature artifacts
- \`spec/features/<feature>/verify-report.md\` — verification output (after tasks / manual verify)

### Create or update a feature

Use the template from \`spec/feature.md\` and provide input as:

\`#<feature># <context>\`

Result: create/update the folder \`spec/features/<feature>/\` and produce \`spec.md\` → \`plan.md\` → \`tasks.md\`.

### Execute tasks

When implementation is requested, execute tasks from:\n\n- \`spec/features/<feature>/tasks.md\`

### Verify

Use \`spec/core/verify.md\` to verify \`spec/features/<feature>/\` and write \`verify-report.md\`.

### Quality bar (for generated artifacts)

- No empty headers, no placeholders
- \`spec.md\`: at least 3 user stories + explicit assumptions
- \`plan.md\`: references concrete decisions from \`spec.md\` (avoid generic plans)
- \`tasks.md\`: checkable, ordered, references concrete paths under \`spec/features/<feature>/\`
- If updating an existing feature, prefer updating existing files; use \`spec/core/hotfix.md\` to describe changes

${AGENTS_END}
`;

  const agentsPath = path.join(targetDir, "AGENTS.md");
  const agentsBlockRegex = new RegExp(
    `${escapeRegExp(AGENTS_START)}[\\s\\S]*?${escapeRegExp(AGENTS_END)}`,
    "m",
  );

  try {
    if (!fs.existsSync(agentsPath)) {
      const initialAgents = `# AGENTS\n\n${agentsWorkflowBlock}\n`;
      fs.writeFileSync(agentsPath, initialAgents, "utf8");
      console.log("Created: AGENTS.md");
    } else {
      const existingAgents = fs.readFileSync(agentsPath, "utf8");
      if (existingAgents.includes(AGENTS_START) && existingAgents.includes(AGENTS_END)) {
        const updatedAgents = existingAgents.replace(agentsBlockRegex, agentsWorkflowBlock).replace(/\s*$/, "\n");
        if (updatedAgents !== existingAgents) {
          fs.writeFileSync(agentsPath, updatedAgents, "utf8");
          console.log("Updated: AGENTS.md (spec-feature block)");
        } else {
          console.log("Skipped: AGENTS.md (spec-feature block unchanged)");
        }
      } else {
        const trimmed = existingAgents.replace(/\s*$/, "");
        const appendedAgents = `${trimmed}\n\n${agentsWorkflowBlock}\n`;
        fs.writeFileSync(agentsPath, appendedAgents, "utf8");
        console.log("Appended: AGENTS.md (spec-feature workflow)");
      }
    }
  } catch (err) {
    console.error("❌ Failed to write AGENTS.md:", err?.message || err);
    process.exit(1);
  }

  console.log(`✅ Spec Feature initialized in '${folderName}' folder!`);
  process.exit(0);
}

console.log("Usage: npx spec-feature init [folder-name]");
process.exit(1);

function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
